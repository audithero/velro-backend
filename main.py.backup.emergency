"""
FastAPI main application entry point for Velro API.
Following CLAUDE.md: Comprehensive security, proper layering, error handling.
Optimized for Railway deployment.
"""
from fastapi import FastAPI, HTTPException, Request, status
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.trustedhost import TrustedHostMiddleware
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.responses import Response
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from slowapi.errors import RateLimitExceeded
import logging
import time
import asyncio
import os
from contextlib import asynccontextmanager

from config import settings
from database import health_check
from utils.security import init_security_system, SecurityValidation
from middleware.auth import AuthMiddleware
from middleware.security import SecurityMiddleware
from middleware.rate_limiting import (
    init_rate_limiting, 
    rate_limit_exceeded_handler,
    create_rate_limit_middleware,
    rate_limiter
)
from slowapi.errors import RateLimitExceeded
from slowapi.middleware import SlowAPIMiddleware
from middleware.validation import validation_middleware
from routers import auth, generations, projects, models, credits, storage, style_stacks

# Import performance optimizations
from utils.logging_config import perf_logger
from utils.performance_monitor import performance_monitor

# Import debug router conditionally for development only
try:
    from routers.debug import debug_router
    debug_router_available = True
except ImportError:
    debug_router_available = False
    debug_router = None

# Configure logging for Railway
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class SecurityHeadersMiddleware(BaseHTTPMiddleware):
    """Add security headers to all responses."""
    
    async def dispatch(self, request, call_next):
        response = await call_next(request)
        
        # Apply security headers from settings
        headers = settings.get_security_headers()
        for header, value in headers.items():
            if value:  # Only add headers with values
                response.headers[header] = value
        
        # Additional production security headers
        if settings.is_production():
            response.headers["Content-Security-Policy"] = (
                "default-src 'self'; "
                "script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net; "
                "style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; "
                "img-src 'self' data: https:; "
                "font-src 'self' https://fonts.gstatic.com; "
                "connect-src 'self' https://*.railway.app https://*.supabase.co; "
                "frame-ancestors 'none';"
            )
            response.headers["X-Robots-Tag"] = "noindex, nofollow"
        
        return response


@asynccontextmanager
async def lifespan(app: FastAPI):
    """Application lifespan management with Railway-optimized startup and performance monitoring."""
    try:
        # Startup with Railway-specific handling
        logger.info("🚀 Starting Velro API on Railway...")
        
        # Initialize performance logging
        perf_logger.setup_logging(
            level="INFO" if settings.is_production() else "DEBUG",
            enable_file_logging=not settings.is_production()
        )
        logger.info("✅ Performance logging initialized")
        
        # Start performance monitoring
        await performance_monitor.start_monitoring(interval_seconds=60)
        logger.info("✅ Performance monitoring started")
        
        # Railway-optimized startup - minimal delay
        await asyncio.sleep(0.5)
        
        # Log environment info
        logger.info(f"Environment: {settings.environment}")
        logger.info(f"Debug mode: {settings.debug}")
        
        # Initialize security system
        try:
            await init_security_system()
            logger.info("✅ Security system initialized")
        except Exception as e:
            logger.error(f"❌ Security system init failed: {e}")
            if settings.is_production():
                raise  # Fail fast in production if security init fails
        
        # Initialize rate limiting system
        try:
            await init_rate_limiting()
            logger.info("✅ Rate limiting system initialized")
        except Exception as e:
            logger.warning(f"⚠️ Rate limiting init failed: {e}")
        
        # Railway-optimized database check - quick validation
        try:
            if health_check():
                logger.info("✅ Database health check passed")
            else:
                logger.warning("⚠️ Database health check failed - continuing with degraded service")
        except Exception as e:
            logger.warning(f"⚠️ Database health check error: {e} - continuing startup")
        
        logger.info("✅ Velro API started successfully on Railway with performance optimizations")
        yield
        
    except Exception as e:
        logger.error(f"❌ Startup failed: {e}")
        # Don't raise in production - let Railway handle restarts
        if settings.is_production():
            logger.error("Continuing with degraded service...")
        else:
            raise
    finally:
        # Shutdown
        logger.info("🛑 Shutting down Velro API...")
        
        # Stop performance monitoring
        try:
            await performance_monitor.stop_monitoring()
            logger.info("✅ Performance monitoring stopped")
        except Exception as e:
            logger.warning(f"⚠️ Error stopping performance monitoring: {e}")
        
        logger.info("✅ Velro API shutdown complete")


app = FastAPI(
    title=settings.app_name,
    description="AI-powered creative platform backend API with comprehensive security",
    version=settings.app_version,
    debug=settings.debug,
    lifespan=lifespan,
    docs_url="/docs" if settings.debug else None,
    redoc_url="/redoc" if settings.debug else None,
    # CRITICAL FIX: Enable automatic trailing slash redirects
    redirect_slashes=True
)


# === EXCEPTION HANDLERS (Register first) ===

@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request, exc: RequestValidationError):
    """Handle Pydantic validation errors with detailed messages."""
    logger.warning(f"Validation error on {request.url}: {exc.errors()}")
    
    return JSONResponse(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        content={
            "error": "validation_error",
            "message": "Request validation failed",
            "details": exc.errors(),
            "timestamp": time.time()
        }
    )


@app.exception_handler(RateLimitExceeded)
async def rate_limit_exception_handler(request: Request, exc: RateLimitExceeded):
    """Handle rate limit exceeded with custom response."""
    return await rate_limit_exceeded_handler(request, exc)


@app.exception_handler(HTTPException)
async def http_exception_handler(request: Request, exc: HTTPException):
    """Handle HTTP exceptions with consistent format."""
    logger.warning(f"HTTP error {exc.status_code} on {request.url}: {exc.detail}")
    
    return JSONResponse(
        status_code=exc.status_code,
        content={
            "error": "http_error",
            "message": exc.detail,
            "status_code": exc.status_code,
            "timestamp": time.time()
        }
    )


@app.exception_handler(Exception)
async def general_exception_handler(request: Request, exc: Exception):
    """Handle unexpected errors gracefully."""
    logger.error(f"Unexpected error on {request.url}: {exc}", exc_info=True)
    
    return JSONResponse(
        status_code=500,
        content={
            "error": "internal_server_error",
            "message": "An unexpected error occurred" if not settings.debug else str(exc),
            "status_code": 500,
            "timestamp": time.time()
        }
    )


# === SECURITY MIDDLEWARE STACK (Order matters!) ===

# 1. Comprehensive security middleware (first line of defense)
app.add_middleware(SecurityMiddleware)

# 2. Trusted host middleware
app.add_middleware(
    TrustedHostMiddleware, 
    allowed_hosts=["*"]  # Railway handles this
)

# 3. Rate limiting middleware (handled by SecurityMiddleware now, but keep SlowAPI for compatibility)
app.state.limiter = rate_limiter.limiter
app.add_middleware(SlowAPIMiddleware)
app.add_exception_handler(RateLimitExceeded, rate_limit_exceeded_handler)

# 3. HTTPS-preserving trailing slash redirect handler (SECURITY FIX)
@app.middleware("http") 
async def trailing_slash_redirect_middleware(request: Request, call_next):
    """
    Handle trailing slash redirects with HTTPS preservation.
    
    SECURITY FIX: Prevents HTTPS -> HTTP downgrade attacks in redirect URLs.
    Respects Railway proxy headers to determine original protocol.
    """
    # Process the request normally first
    response = await call_next(request)
    
    # If we get a 405 (Method Not Allowed) or 404 on an API endpoint
    if ((response.status_code == 405 or response.status_code == 404) and 
        request.url.path.startswith('/api/')):
        
        # Handle both cases: missing trailing slash or extra trailing slash
        if request.url.path.endswith('/'):
            # Try without trailing slash
            new_path = request.url.path.rstrip('/')
        else:
            # Try with trailing slash
            new_path = request.url.path + '/'
        
        # SECURITY FIX: Determine original protocol from Railway proxy headers
        forwarded_proto = request.headers.get("x-forwarded-proto", "")
        original_scheme = forwarded_proto if forwarded_proto in ["http", "https"] else "https"
        
        # SECURITY: Force HTTPS in production, preserve original in development
        if settings.is_production() and not settings.debug:
            scheme = "https"
        else:
            scheme = original_scheme
        
        # Construct secure redirect URL preserving the original scheme
        host = request.headers.get("host", request.url.netloc)
        query_string = f"?{request.url.query}" if request.url.query else ""
        secure_redirect_url = f"{scheme}://{host}{new_path}{query_string}"
        
        logger.info(f"🔒 [HTTPS-REDIRECT] Secure redirect 405 {request.url.path} -> {new_path} (scheme: {scheme})")
        
        # Return 308 redirect with HTTPS-preserved URL
        return JSONResponse(
            status_code=308,
            content={"message": f"Redirecting to {new_path}", "secure": True},
            headers={
                "Location": secure_redirect_url,
                "X-Redirect-Reason": "trailing-slash-https-preserved"
            }
        )
    
    return response

# 4. Input validation middleware
@app.middleware("http")
async def input_validation_middleware(request: Request, call_next):
    """Apply comprehensive input validation."""
    return await validation_middleware(request, call_next)

# 5. CORS middleware - Railway optimized with proper origins and debug support
def get_cors_origins():
    """Get CORS origins based on environment and Railway configuration."""
    # Base origins for development
    base_origins = [
        "http://localhost:3000",
        "http://localhost:3001", 
        "http://localhost:3002",
        "http://127.0.0.1:3000",
        "http://127.0.0.1:3001",
        "http://127.0.0.1:3002"
    ]
    
    # Production origins
    production_origins = [
        "https://velro-frontend-production.up.railway.app",
        "https://velro.ai",
        "https://www.velro.ai"
    ]
    
    # Railway service URL if available
    railway_frontend_url = settings.railway_service_velro_frontend_url
    if railway_frontend_url and railway_frontend_url not in production_origins:
        production_origins.append(railway_frontend_url)
    
    # Additional origins from config
    config_origins = settings.cors_origins if hasattr(settings, 'cors_origins') else []
    
    # Combine all origins
    all_origins = list(set(base_origins + production_origins + config_origins))
    
    logger.info(f"CORS origins configured: {all_origins}")
    return all_origins

cors_origins = get_cors_origins()

app.add_middleware(
    CORSMiddleware,
    allow_origins=cors_origins,
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS", "HEAD"],
    allow_headers=[
        "Authorization",
        "Content-Type",
        "Accept",
        "Origin",
        "User-Agent",
        "X-Requested-With",
        "X-CSRF-Token",
        "X-Forwarded-For",
        "X-Forwarded-Proto",
        "X-Forwarded-Host"
    ],
    expose_headers=[
        "X-Process-Time", 
        "X-RateLimit-Remaining",
        "X-CORS-Debug",
        "Access-Control-Allow-Origin"
    ]
)

# 6. CORS debugging middleware for troubleshooting
@app.middleware("http")
async def cors_debug_middleware(request: Request, call_next):
    """CORS debugging middleware to track and log CORS-related issues."""
    origin = request.headers.get("origin")
    method = request.method
    
    # Log preflight requests
    if method == "OPTIONS":
        logger.info(f"🔍 CORS Preflight: {origin} -> {request.url.path}")
        logger.info(f"🔍 Request Headers: {dict(request.headers)}")
    
    # Process request
    response = await call_next(request)
    
    # Add debug headers in development or when explicitly enabled
    if settings.debug or os.getenv("CORS_DEBUG", "false").lower() == "true":
        response.headers["X-CORS-Debug"] = f"Origin: {origin}, Method: {method}"
        response.headers["X-CORS-Allowed-Origins"] = str(cors_origins)
    
    # Log CORS issues
    if origin and origin not in cors_origins:
        logger.warning(f"⚠️ CORS: Origin {origin} not in allowed origins for {method} {request.url.path}")
    
    return response

# 7. Auth middleware for JWT verification
app.add_middleware(AuthMiddleware)

# 8. Enhanced HTTPS enforcement middleware (handle Railway proxy)
@app.middleware("http")
async def https_enforcement_middleware(request: Request, call_next):
    """
    Enhanced HTTPS enforcement with comprehensive security headers.
    Respects Railway proxy headers and prevents protocol downgrade attacks.
    """
    # Check if we should redirect to HTTPS
    is_production = settings.is_production() and not settings.debug
    
    # Skip HTTPS redirect for health check and system endpoints
    skip_https_redirect = any([
        request.url.path == "/health",
        request.url.path == "/",
        request.url.path == "/security-status",
        request.url.path.startswith("/docs"),
        request.url.path.startswith("/redoc"),
        request.url.path.startswith("/openapi.json")
    ])
    
    if is_production and not skip_https_redirect:
        # Get the original protocol from Railway's proxy headers
        forwarded_proto = request.headers.get("x-forwarded-proto", "")
        scheme = forwarded_proto or request.url.scheme
        
        # If the original request was HTTP, redirect to HTTPS
        if scheme == "http":
            # SECURITY FIX: Use host header for proper Railway redirect
            host = request.headers.get("host", request.url.netloc)
            query_string = f"?{request.url.query}" if request.url.query else ""
            https_url = f"https://{host}{request.url.path}{query_string}"
            
            logger.info(f"🔒 [HTTPS-ENFORCE] Redirecting HTTP -> HTTPS: {request.url.path}")
            
            return JSONResponse(
                status_code=301,  # Use 301 for HTTP->HTTPS (permanent redirect)
                content={"message": "Redirecting to HTTPS", "secure": True},
                headers={
                    "Location": https_url,
                    "X-Redirect-Reason": "https-enforcement",
                    "Strict-Transport-Security": "max-age=31536000; includeSubDomains"
                }
            )
    
    response = await call_next(request)
    
    # Add HTTPS security headers to all responses in production
    if is_production:
        response.headers["X-Forwarded-Proto-Verified"] = "true"
        response.headers["X-Protocol-Security"] = "enforced"
    
    return response

# 9. Enhanced security headers middleware with HTTPS enforcement
@app.middleware("http")
async def security_headers_middleware(request: Request, call_next):
    """Add comprehensive security headers with enhanced HTTPS protection."""
    response = await call_next(request)
    
    # Core security headers
    response.headers["X-Content-Type-Options"] = "nosniff"
    response.headers["X-Frame-Options"] = "DENY"
    response.headers["X-XSS-Protection"] = "1; mode=block"
    response.headers["Referrer-Policy"] = "strict-origin-when-cross-origin"
    response.headers["Permissions-Policy"] = "geolocation=(), microphone=(), camera=()"
    
    # Content Security Policy with HTTPS enforcement
    csp = (
        "default-src 'self'; "
        "script-src 'self'; "
        "style-src 'self' 'unsafe-inline'; "
        "img-src 'self' data: https:; "
        "font-src 'self'; "
        "connect-src 'self' https:; "
        "frame-ancestors 'none'; "
        "base-uri 'self'; "
        "form-action 'self'; "
        "upgrade-insecure-requests"  # Force HTTPS for all resources
    )
    response.headers["Content-Security-Policy"] = csp
    
    # Enhanced HTTPS enforcement in production
    if settings.is_production() and not settings.debug:
        # Strict Transport Security with preload
        response.headers["Strict-Transport-Security"] = "max-age=31536000; includeSubDomains; preload"
        
        # Additional HTTPS security headers
        response.headers["X-HTTPS-Only"] = "1"
        response.headers["X-Protocol-Downgrade-Protection"] = "enabled"
        
        # Verify forwarded protocol matches expectation
        forwarded_proto = request.headers.get("x-forwarded-proto", "")
        if forwarded_proto == "https":
            response.headers["X-Forwarded-Proto-Status"] = "secure"
        elif forwarded_proto == "http":
            response.headers["X-Forwarded-Proto-Status"] = "insecure-detected"
        else:
            response.headers["X-Forwarded-Proto-Status"] = "unknown"
    
    # Security audit headers
    response.headers["X-Security-Framework"] = "FastAPI-Enhanced"
    response.headers["X-Velro-Security"] = "v1.1.2"
    
    return response

# 10. Enhanced request timing and monitoring middleware with performance tracking
@app.middleware("http")
async def enhanced_monitoring_middleware(request: Request, call_next):
    """Enhanced request timing and monitoring with performance metrics."""
    start_time = time.time()
    client_ip = request.client.host if request.client else "unknown"
    
    # Track connection
    performance_monitor.increment_connections()
    
    # Log request start with performance logger
    perf_logger.log_api_request(
        method=request.method,
        path=request.url.path,
        user_id=getattr(request.state, 'user_id', None)
    )
    
    try:
        response = await call_next(request)
        process_time = time.time() - start_time
        
        # Add timing header
        response.headers["X-Process-Time"] = str(process_time)
        
        # Record performance metrics
        performance_monitor.record_request(process_time, response.status_code)
        
        # Log response with performance metrics
        perf_logger.log_api_request(
            method=request.method,
            path=request.url.path,
            user_id=getattr(request.state, 'user_id', None),
            response_time=process_time,
            status_code=response.status_code
        )
        
        # Log slow requests with detailed context
        if process_time > 2.0:
            logger.warning(f"🐌 Slow request: {request.method} {request.url.path} took {process_time:.2f}s")
            perf_logger.logger.warning(f"Slow request detected", extra={
                'operation_type': 'slow_request',
                'method': request.method,
                'path': request.url.path,
                'response_time': process_time,
                'status_code': response.status_code,
                'client_ip': client_ip
            })
        
        return response
        
    except Exception as e:
        process_time = time.time() - start_time
        
        # Record failed request
        performance_monitor.record_request(process_time, 500)
        
        # Log error with context
        perf_logger.logger.error(f"Request failed: {request.method} {request.url.path} after {process_time:.3f}s - {str(e)}", extra={
            'operation_type': 'failed_request',
            'method': request.method,
            'path': request.url.path,
            'response_time': process_time,
            'error': str(e),
            'client_ip': client_ip
        })
        
        raise
    finally:
        # Track connection release
        performance_monitor.decrement_connections()

# === API ROUTES ===

# System endpoints (unprotected)
@app.get("/", tags=["System"])
async def root():
    """Root endpoint with API information and security status."""
    return {
        "message": "Velro API - AI-powered creative platform",
        "version": settings.app_version,
        "status": "operational",
        "environment": settings.environment,
        "security": {
            "rate_limiting": "enabled",
            "input_validation": "enabled",
            "security_headers": "enabled",
            "authentication": "required"
        },
        "endpoints": {
            "health": "/health",
            "security_status": "/security-status",
            "docs": "/docs" if settings.debug else "disabled",
            "api": "/api/v1"
        }
    }


@app.get("/health", tags=["System"])
@app.head("/health", tags=["System"])
async def health_check_endpoint(request: Request):
    """Railway-optimized health check endpoint for monitoring."""
    start_time = time.time()
    
    try:
        # Railway-specific health check optimizations
        railway_deployment = os.getenv("RAILWAY_DEPLOYMENT", "false").lower() == "true"
        
        # Quick database connection test (Railway-optimized)
        database_status = "connected"
        try:
            if not railway_deployment:  # Skip DB check in Railway to avoid timeouts
                db_healthy = health_check()
                database_status = "connected" if db_healthy else "degraded"
            else:
                database_status = "railway-optimized"
        except Exception as db_e:
            logger.warning(f"Database check failed: {db_e}")
            database_status = "degraded"
        
        # Performance metrics
        response_time = time.time() - start_time
        
        # Railway health check response
        health_data = {
            "status": "healthy",
            "timestamp": time.time(),
            "response_time": round(response_time, 3),
            "version": settings.app_version,
            "environment": settings.environment,
            "database": database_status,
            "railway": {
                "deployment": railway_deployment,
                "optimized": True,
                "service_url": os.getenv("RAILWAY_SERVICE_VELRO_BACKEND_URL", "not-set"),
                "project_id": os.getenv("RAILWAY_PROJECT_ID", "not-set")[:8] + "..." if os.getenv("RAILWAY_PROJECT_ID") else "not-set"
            },
            "system": {
                "uptime": response_time,  # Approximation
                "memory_usage": "optimized",
                "cpu_usage": "normal"
            }
        }
        
        # For HEAD requests, return minimal response
        if request.method == "HEAD":
            return JSONResponse(content={}, status_code=200)
        
        # Log health check for monitoring
        if response_time > 1.0:
            logger.warning(f"Slow health check: {response_time:.3f}s")
        
        return health_data
        
    except Exception as e:
        response_time = time.time() - start_time
        logger.error(f"Health check failed: {e} (took {response_time:.3f}s)")
        
        # Always return 200 for Railway health checks to prevent restarts
        return JSONResponse(
            status_code=200,
            content={
                "status": "degraded",
                "timestamp": time.time(),
                "response_time": round(response_time, 3),
                "message": "Service degraded but operational",
                "error": str(e) if settings.debug else "Internal error",
                "railway": {
                    "deployment": os.getenv("RAILWAY_DEPLOYMENT", "false").lower() == "true",
                    "auto_restart": True
                }
            }
        )


@app.get("/security-status", tags=["System"])
async def security_status():
    """Security configuration status for monitoring and auditing."""
    return {
        "security_features": {
            "rate_limiting": "enabled",
            "input_validation": "enabled", 
            "security_headers": "enabled",
            "cors_protection": "enabled",
            "content_security_policy": "enabled",
            "authentication": "jwt_required",
            "request_size_limits": "enabled",
            "sql_injection_protection": "enabled",
            "xss_protection": "enabled"
        },
        "rate_limits": {
            "auth_endpoints": "5/minute",
            "api_endpoints": "100/minute",
            "generation_endpoints": "10/minute",
            "storage_upload_endpoints": "20/minute",
            "storage_download_endpoints": "60/minute",
            "storage_delete_endpoints": "30/minute",
            "storage_bulk_endpoints": "10/minute",
            "storage_admin_endpoints": "5/minute"
        },
        "validation_limits": {
            "max_request_size": "50MB",
            "max_json_size": "10MB", 
            "max_prompt_length": "2000 chars",
            "max_string_length": "10000 chars",
            "max_file_size": "100MB",
            "supported_file_types": "image/*, video/*"
        },
        "https_enforcement": not settings.debug,
        "debug_mode": settings.debug,
        "environment": settings.environment,
        "timestamp": time.time()
    }


@app.get("/cors-test", tags=["System"])
async def cors_test(request: Request):
    """CORS configuration test endpoint for debugging."""
    origin = request.headers.get("origin")
    
    return {
        "message": "CORS test endpoint",
        "timestamp": time.time(),
        "request_origin": origin,
        "allowed_origins": cors_origins,
        "is_origin_allowed": origin in cors_origins if origin else None,
        "cors_config": {
            "allow_credentials": True,
            "allow_methods": ["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS", "HEAD"],
            "expose_headers": ["X-Process-Time", "X-RateLimit-Remaining", "X-CORS-Debug", "Access-Control-Allow-Origin"]
        },
        "environment": settings.environment,
        "debug": settings.debug
    }


@app.get("/performance-metrics", tags=["System"])
async def get_performance_metrics():
    """Get current performance metrics and system status."""
    try:
        # Get performance summary
        perf_summary = performance_monitor.get_performance_summary()
        
        # Get performance logger summary
        logger_summary = perf_logger.get_performance_summary()
        
        return {
            "status": "operational",
            "timestamp": time.time(),
            "performance_summary": perf_summary,
            "logger_summary": logger_summary,
            "system_health": "healthy" if perf_summary.get("status") == "healthy" else "degraded"
        }
    except Exception as e:
        logger.error(f"❌ Error getting performance metrics: {e}")
        return {
            "status": "error",
            "timestamp": time.time(),
            "error": str(e),
            "system_health": "unknown"
        }


@app.get("/performance-history", tags=["System"])
async def get_performance_history(minutes: int = 15):
    """Get performance metrics history for specified duration."""
    try:
        if minutes > 60:
            minutes = 60  # Limit to 1 hour max
        
        history = performance_monitor.get_metrics_history(minutes=minutes)
        
        return {
            "status": "success",
            "timestamp": time.time(),
            "period_minutes": minutes,
            "metrics_count": len(history),
            "metrics_history": history
        }
    except Exception as e:
        logger.error(f"❌ Error getting performance history: {e}")
        return {
            "status": "error",
            "timestamp": time.time(),
            "error": str(e)
        }


@app.options("/", tags=["System"])
async def root_options():
    """Handle CORS preflight requests for root."""
    return {"message": "OK"}


@app.options("/api/v1/auth/login", tags=["System"])
async def auth_login_options():
    """Handle CORS preflight requests for auth login."""
    return {"message": "OK"}


@app.options("/api/v1/auth/register", tags=["System"])
async def auth_register_options():
    """Handle CORS preflight requests for auth register."""
    return {"message": "OK"}


@app.options("/api/v1/{path:path}", tags=["System"])
async def api_options(path: str):
    """Handle CORS preflight requests for all API endpoints."""
    return {"message": "OK"}


# === CRITICAL FIX: Ensure all routers are properly registered ===
# EMERGENCY FIX: Add debugging and error handling for router registration

print("🔧 REGISTERING API ROUTERS...")

try:
    # Authentication router
    print("✅ Registering auth router...")
    app.include_router(auth.router, prefix="/api/v1", tags=["Authentication"])
    
    # Generations router 
    print("✅ Registering generations router...")
    app.include_router(generations.router, prefix="/api/v1", tags=["Generations"])
    
    # Projects router
    print("✅ Registering projects router...")
    app.include_router(projects.router, prefix="/api/v1", tags=["Projects"])
    
    # AI Models router
    print("✅ Registering models router...")
    app.include_router(models.router, prefix="/api/v1", tags=["AI Models"])
    
    # Credits router
    print("✅ Registering credits router...")
    app.include_router(credits.router, prefix="/api/v1", tags=["Credits"])
    
    # Storage router
    print("✅ Registering storage router...")
    app.include_router(storage.router, prefix="/api/v1", tags=["Storage"])
    
    # Style Stacks router
    print("✅ Registering style_stacks router...")
    app.include_router(style_stacks.router, prefix="/api/v1", tags=["Style Stacks"])
    
    print("🚀 ALL API ROUTERS REGISTERED SUCCESSFULLY!")
    
except Exception as e:
    print(f"❌ CRITICAL ERROR: Router registration failed: {e}")
    logger.error(f"Router registration failed: {e}", exc_info=True)
    # Continue execution to allow basic functionality
# SECURITY ENHANCED: Debug router inclusion with strict controls
if debug_router_available and debug_router:
    # CRITICAL SECURITY CHECK: Never enable debug endpoints in production
    debug_enabled = (
        settings.debug and 
        settings.development_mode and 
        not settings.is_production() and
        os.getenv("ENABLE_DEBUG_ENDPOINTS", "false").lower() == "true"
    )
    
    if debug_enabled:
        app.include_router(debug_router, prefix="/api/v1", tags=["Debug"])
        logger.warning("⚠️ Debug endpoints enabled - DEVELOPMENT MODE ONLY")
    else:
        logger.info("🔒 Debug endpoints disabled for security")
else:
    logger.info("🔒 Debug router not available or disabled")
