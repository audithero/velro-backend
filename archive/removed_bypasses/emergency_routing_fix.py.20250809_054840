#!/usr/bin/env python3
"""
EMERGENCY ROUTING FIX - Critical production issue resolution
Root cause: FastAPI router registration or environment configuration failure
This script tests and fixes the API routing issue causing 404 errors.
"""

import asyncio
import httpx
import json
from datetime import datetime

class EmergencyRoutingDiagnostic:
    def __init__(self):
        self.base_url = "https://velro-backend.railway.app"
        self.results = {
            "timestamp": datetime.now().isoformat(),
            "tests": [],
            "issues_identified": [],
            "fixes_applied": [],
            "status": "running"
        }
    
    async def test_endpoint(self, client: httpx.AsyncClient, path: str, expected_status: int = 200):
        """Test a specific endpoint and record results."""
        try:
            response = await client.get(f"{self.base_url}{path}")
            test_result = {
                "path": path,
                "status_code": response.status_code,
                "expected": expected_status,
                "success": response.status_code == expected_status,
                "response_length": len(response.text),
                "headers": dict(response.headers)
            }
            
            # Store response content for analysis
            if response.status_code != expected_status:
                test_result["response_text"] = response.text[:500]  # First 500 chars
                
            self.results["tests"].append(test_result)
            return test_result
        except Exception as e:
            error_result = {
                "path": path,
                "error": str(e),
                "success": False
            }
            self.results["tests"].append(error_result)
            return error_result
    
    async def comprehensive_diagnosis(self):
        """Run comprehensive routing diagnosis."""
        print("🚨 EMERGENCY ROUTING DIAGNOSTIC STARTING...")
        
        async with httpx.AsyncClient(timeout=30.0) as client:
            # Test core endpoints
            endpoints_to_test = [
                ("/", 200),
                ("/health", 200),
                ("/docs", 200),  # Should work if debug enabled
                ("/openapi.json", 200),  # Should work if debug enabled
                ("/api/v1/projects", 401),  # Should return unauthorized, not 404
                ("/api/v1/auth/login", 405),  # Should allow POST, not GET
                ("/api/v1/models", 401),  # Should return unauthorized, not 404
                ("/security-status", 200),
                ("/performance-metrics", 200)
            ]
            
            print(f"Testing {len(endpoints_to_test)} critical endpoints...")
            
            for path, expected_status in endpoints_to_test:
                result = await self.test_endpoint(client, path, expected_status)
                status_icon = "✅" if result.get("success") else "❌"
                print(f"{status_icon} {path}: {result.get('status_code', 'ERROR')}")
                
                # Analyze failures
                if not result.get("success"):
                    if result.get("status_code") == 404 and path.startswith("/api/"):
                        self.results["issues_identified"].append({
                            "type": "routing_failure",
                            "path": path,
                            "issue": "API routes returning 404 - router not registered correctly"
                        })
                    elif result.get("status_code") == 404 and path in ["/docs", "/openapi.json"]:
                        self.results["issues_identified"].append({
                            "type": "docs_disabled",
                            "path": path,
                            "issue": "Documentation endpoints disabled - production mode or debug=False"
                        })
    
    async def analyze_root_cause(self):
        """Analyze test results to identify root cause."""
        print("\n🔍 ANALYZING ROOT CAUSE...")
        
        api_404_count = sum(1 for test in self.results["tests"] 
                           if test.get("path", "").startswith("/api/") and test.get("status_code") == 404)
        
        docs_404_count = sum(1 for test in self.results["tests"] 
                            if test.get("path") in ["/docs", "/openapi.json"] and test.get("status_code") == 404)
        
        root_working = any(test.get("path") == "/" and test.get("success") 
                          for test in self.results["tests"])
        
        health_working = any(test.get("path") == "/health" and test.get("success") 
                           for test in self.results["tests"])
        
        print(f"📊 Analysis Results:")
        print(f"   - Root endpoint working: {root_working}")
        print(f"   - Health endpoint working: {health_working}")
        print(f"   - API endpoints returning 404: {api_404_count}")
        print(f"   - Docs endpoints returning 404: {docs_404_count}")
        
        if api_404_count > 0 and root_working and health_working:
            self.results["root_cause"] = "API_ROUTER_REGISTRATION_FAILURE"
            print("🚨 ROOT CAUSE IDENTIFIED: API Router Registration Failure")
            print("   The FastAPI app is running but API routers are not properly registered")
            
        elif docs_404_count > 0 and api_404_count > 0:
            self.results["root_cause"] = "PRODUCTION_MODE_ROUTING_ISSUE"  
            print("🚨 ROOT CAUSE IDENTIFIED: Production Mode Configuration Issue")
            print("   Both docs and API endpoints failing - environment configuration problem")
            
        return self.results["root_cause"]
    
    def generate_fix_recommendations(self):
        """Generate specific fix recommendations based on diagnosis."""
        root_cause = self.results.get("root_cause")
        
        if root_cause == "API_ROUTER_REGISTRATION_FAILURE":
            self.results["fix_recommendations"] = [
                "Check main.py router includes - ensure all routers are properly registered",
                "Verify import paths in router includes",
                "Check for startup exceptions preventing router registration",
                "Validate middleware order is not blocking router registration",
                "Test local deployment to confirm router configuration"
            ]
        elif root_cause == "PRODUCTION_MODE_ROUTING_ISSUE":
            self.results["fix_recommendations"] = [
                "Check ENVIRONMENT variable setting in Railway",
                "Verify DEBUG mode configuration", 
                "Check for production security validation failures",
                "Validate JWT_SECRET and other required environment variables",
                "Check application startup logs for configuration errors"
            ]
        else:
            self.results["fix_recommendations"] = [
                "Full application restart required",
                "Check Railway deployment logs for errors",
                "Validate all environment variables are set correctly",
                "Test application locally to isolate deployment issues"
            ]
    
    async def run_emergency_diagnostic(self):
        """Run complete emergency diagnostic."""
        await self.comprehensive_diagnosis()
        await self.analyze_root_cause()
        self.generate_fix_recommendations()
        
        self.results["status"] = "completed"
        
        # Save results
        with open("emergency_routing_diagnostic_results.json", "w") as f:
            json.dump(self.results, f, indent=2)
        
        print(f"\n📄 Full diagnostic results saved to: emergency_routing_diagnostic_results.json")
        print(f"🎯 Root Cause: {self.results.get('root_cause', 'UNKNOWN')}")
        print(f"🔧 Fix Recommendations:")
        for i, rec in enumerate(self.results.get("fix_recommendations", []), 1):
            print(f"   {i}. {rec}")
        
        return self.results

async def main():
    """Run emergency diagnostic."""
    diagnostic = EmergencyRoutingDiagnostic()
    results = await diagnostic.run_emergency_diagnostic()
    return results

if __name__ == "__main__":
    asyncio.run(main())