#!/usr/bin/env python3
"""
Setup local test environment for Velro backend deployment testing.
Creates test configuration and validates all components.
"""

import os
import sys
import json
import secrets
import string
from pathlib import Path
from typing import Dict, Any

class TestEnvironmentSetup:
    def __init__(self):
        self.backend_dir = Path(__file__).parent
        self.env_file = self.backend_dir / ".env"
        self.test_env_template = self.backend_dir / "test_env_template.env"
        
    def generate_jwt_secret(self, length: int = 64) -> str:
        """Generate a secure JWT secret key."""
        alphabet = string.ascii_letters + string.digits + "!@#$%^&*"
        return ''.join(secrets.choice(alphabet) for _ in range(length))
    
    def create_test_env_file(self) -> bool:
        """Create or update .env file with test configuration."""
        print("ğŸ”§ Setting up test environment file...")
        
        # Read existing .env if it exists
        existing_env = {}
        if self.env_file.exists():
            try:
                content = self.env_file.read_text()
                for line in content.split('\n'):
                    line = line.strip()
                    if line and '=' in line and not line.startswith('#'):
                        key, value = line.split('=', 1)
                        existing_env[key.strip()] = value.strip()
                print(f"ğŸ“„ Found existing .env with {len(existing_env)} variables")
            except Exception as e:
                print(f"âš ï¸  Warning: Could not parse existing .env: {e}")
        
        # Required test configuration
        test_config = {
            "ENVIRONMENT": "development",
            "DEBUG": "true",
            "APP_NAME": "Velro API Test",
            "APP_VERSION": "1.0.0-test",
            "JWT_ALGORITHM": "HS256",
            "CORS_ORIGINS": '["http://localhost:3000", "http://localhost:8000"]',
            "RATE_LIMIT_ENABLED": "true",
            "RATE_LIMIT_PER_MINUTE": "100",
            "BCRYPT_ROUNDS": "12",
            "SESSION_TIMEOUT": "3600",
            "LOG_LEVEL": "INFO",
            "MAX_FILE_SIZE": "104857600",
            "ALLOWED_FILE_TYPES": "image/jpeg,image/png,image/webp,image/gif"
        }
        
        # Generate JWT secret if not exists
        if "JWT_SECRET_KEY" not in existing_env:
            test_config["JWT_SECRET_KEY"] = self.generate_jwt_secret()
            print("ğŸ” Generated new JWT secret key")
        
        # Merge with existing config (existing values take precedence)
        final_config = {**test_config, **existing_env}
        
        # Check for required Supabase values
        required_supabase = ["SUPABASE_URL", "SUPABASE_SERVICE_KEY"]
        missing_supabase = [key for key in required_supabase if key not in final_config or not final_config[key]]
        
        if missing_supabase:
            print("âš ï¸  Missing required Supabase configuration:")
            for key in missing_supabase:
                print(f"   {key}")
            print("\nğŸ”— Get your Supabase credentials from:")
            print("   https://app.supabase.com/project/YOUR_PROJECT/settings/api")
            
            # Add placeholder values
            for key in missing_supabase:
                final_config[key] = f"PLACEHOLDER_{key}_REPLACE_ME"
        
        # Write updated .env file
        try:
            env_content = []
            env_content.append("# Velro Backend Test Environment Configuration")
            env_content.append(f"# Generated by setup_test_environment.py")
            env_content.append("")
            
            # Group related settings
            groups = {
                "Application": ["ENVIRONMENT", "DEBUG", "APP_NAME", "APP_VERSION"],
                "Authentication": ["JWT_SECRET_KEY", "JWT_ALGORITHM", "BCRYPT_ROUNDS", "SESSION_TIMEOUT"],
                "Supabase": ["SUPABASE_URL", "SUPABASE_SERVICE_KEY", "SUPABASE_ANON_KEY"],
                "CORS": ["CORS_ORIGINS"],
                "Rate Limiting": ["RATE_LIMIT_ENABLED", "RATE_LIMIT_PER_MINUTE"],
                "Storage": ["MAX_FILE_SIZE", "ALLOWED_FILE_TYPES"],
                "External APIs": ["FAL_KEY", "REDIS_URL"],
                "Logging": ["LOG_LEVEL"]
            }
            
            for group_name, keys in groups.items():
                env_content.append(f"# {group_name}")
                for key in keys:
                    if key in final_config:
                        value = final_config[key]
                        env_content.append(f"{key}={value}")
                        del final_config[key]
                env_content.append("")
            
            # Add any remaining variables
            if final_config:
                env_content.append("# Other Variables")
                for key, value in sorted(final_config.items()):
                    env_content.append(f"{key}={value}")
                env_content.append("")
            
            self.env_file.write_text('\n'.join(env_content))
            print(f"âœ… Created test environment file: {self.env_file}")
            
            return len(missing_supabase) == 0
            
        except Exception as e:
            print(f"âŒ Failed to create .env file: {e}")
            return False
    
    def validate_test_dependencies(self) -> bool:
        """Validate that all required dependencies are available."""
        print("ğŸ“¦ Validating test dependencies...")
        
        required_packages = [
            "fastapi",
            "uvicorn", 
            "pydantic",
            "supabase",
            "python-jose",
            "httpx",
            "toml"
        ]
        
        missing_packages = []
        
        for package in required_packages:
            try:
                __import__(package.replace('-', '_'))
            except ImportError:
                missing_packages.append(package)
        
        if missing_packages:
            print("âŒ Missing required packages:")
            for package in missing_packages:
                print(f"   {package}")
            print("\nğŸ“¥ Install missing packages with:")
            print(f"   pip install {' '.join(missing_packages)}")
            return False
        
        print(f"âœ… All {len(required_packages)} required packages available")
        return True
    
    def create_test_startup_script(self) -> bool:
        """Create a test startup script."""
        print("ğŸš€ Creating test startup script...")
        
        startup_script = self.backend_dir / "start_test_server.py"
        
        script_content = '''#!/usr/bin/env python3
"""
Test server startup script for local deployment testing.
"""

import os
import sys
import asyncio
import subprocess
from pathlib import Path

async def start_test_server():
    """Start the test server with proper configuration."""
    print("ğŸš€ Starting Velro Test Server")
    print("=" * 40)
    
    # Set test port
    os.environ["PORT"] = "8000"
    
    # Change to backend directory
    backend_dir = Path(__file__).parent
    os.chdir(backend_dir)
    
    print(f"ğŸ“ Working directory: {backend_dir}")
    print(f"ğŸ”Œ Server will start on: http://localhost:8000")
    print(f"ğŸ“Š Health check: http://localhost:8000/health")
    print(f"ğŸ“– API docs: http://localhost:8000/docs")
    print()
    
    # Start uvicorn server
    cmd = [
        sys.executable, "-m", "uvicorn",
        "main:app",
        "--host", "0.0.0.0",
        "--port", "8000",
        "--reload",
        "--log-level", "info"
    ]
    
    print(f"ğŸ¯ Starting server with command: {' '.join(cmd)}")
    print("â¹ï¸  Press Ctrl+C to stop the server")
    print("=" * 40)
    
    try:
        subprocess.run(cmd)
    except KeyboardInterrupt:
        print("\\nğŸ›‘ Server stopped by user")
    except Exception as e:
        print(f"âŒ Server failed: {e}")
        sys.exit(1)

if __name__ == "__main__":
    asyncio.run(start_test_server())
'''
        
        try:
            startup_script.write_text(script_content)
            startup_script.chmod(0o755)  # Make executable
            print(f"âœ… Created test startup script: {startup_script}")
            return True
        except Exception as e:
            print(f"âŒ Failed to create startup script: {e}")
            return False
    
    def create_quick_test_script(self) -> bool:
        """Create a quick API test script."""
        print("ğŸ§ª Creating quick test script...")
        
        test_script = self.backend_dir / "quick_api_test.py"
        
        script_content = '''#!/usr/bin/env python3
"""
Quick API test script for deployment validation.
"""

import asyncio
import httpx
import json
import time

async def test_api_endpoints():
    """Test critical API endpoints."""
    base_url = "http://localhost:8000"
    
    print("ğŸ§ª Quick API Test")
    print("=" * 30)
    print(f"ğŸ¯ Testing: {base_url}")
    print()
    
    endpoints = [
        ("/", "Root endpoint"),
        ("/health", "Health check"),
        ("/security-status", "Security status"),
        ("/api/v1/models", "AI Models"),
    ]
    
    async with httpx.AsyncClient(timeout=10) as client:
        for endpoint, description in endpoints:
            try:
                print(f"ğŸ“¡ Testing {endpoint} ({description})...")
                start_time = time.time()
                
                response = await client.get(f"{base_url}{endpoint}")
                response_time = time.time() - start_time
                
                if response.status_code == 200:
                    print(f"   âœ… {response.status_code} - {response_time:.3f}s")
                    
                    # Show response preview for key endpoints
                    if endpoint in ["/", "/health"]:
                        data = response.json()
                        if isinstance(data, dict):
                            status = data.get("status", "unknown")
                            print(f"   ğŸ“Š Status: {status}")
                        
                elif response.status_code in [401, 403]:
                    print(f"   ğŸ”’ {response.status_code} - Protected endpoint (OK)")
                else:
                    print(f"   âš ï¸  {response.status_code} - Unexpected status")
                    
            except Exception as e:
                print(f"   âŒ Failed: {str(e)}")
            
            print()
    
    print("ğŸ‰ API test completed!")

if __name__ == "__main__":
    asyncio.run(test_api_endpoints())
'''
        
        try:
            test_script.write_text(script_content)
            test_script.chmod(0o755)  # Make executable
            print(f"âœ… Created quick test script: {test_script}")
            return True
        except Exception as e:
            print(f"âŒ Failed to create test script: {e}")
            return False
    
    def setup_test_environment(self) -> Dict[str, Any]:
        """Setup complete test environment."""
        print("ğŸ”§ Setting up Velro Backend Test Environment")
        print("=" * 50)
        
        # Change to backend directory
        os.chdir(self.backend_dir)
        print(f"ğŸ“ Working in: {self.backend_dir}")
        
        results = {}
        
        # Step 1: Validate dependencies
        results["dependencies"] = self.validate_test_dependencies()
        
        # Step 2: Create environment file
        results["environment"] = self.create_test_env_file()
        
        # Step 3: Create startup script
        results["startup_script"] = self.create_test_startup_script()
        
        # Step 4: Create test script
        results["test_script"] = self.create_quick_test_script()
        
        # Summary
        success_count = sum(results.values())
        total_steps = len(results)
        
        print("\n" + "=" * 50)
        print("ğŸ“Š TEST ENVIRONMENT SETUP SUMMARY")
        print("=" * 50)
        print(f"Completed: {success_count}/{total_steps} steps")
        
        for step, success in results.items():
            status = "âœ…" if success else "âŒ"
            print(f"{status} {step.replace('_', ' ').title()}")
        
        if success_count == total_steps:
            print("\nğŸ‰ Test environment setup completed successfully!")
            print("\nğŸš€ Next steps:")
            print("1. Update .env file with your Supabase credentials")
            print("2. Run: python3 start_test_server.py")
            print("3. In another terminal: python3 quick_api_test.py")
            print("4. Run full deployment tests: python3 test_deployment_fixes.py")
        else:
            print("\nâš ï¸  Some setup steps failed - check errors above")
        
        return {
            "summary": {
                "total_steps": total_steps,
                "completed_steps": success_count,
                "success_rate": (success_count / total_steps) * 100,
                "setup_successful": success_count == total_steps
            },
            "results": results
        }


def main():
    """Main setup execution."""
    setup = TestEnvironmentSetup()
    
    try:
        report = setup.setup_test_environment()
        
        # Save setup report
        report_file = Path("test_environment_setup_report.json")
        with open(report_file, "w") as f:
            json.dump(report, f, indent=2)
        
        print(f"\nğŸ“„ Setup report saved to: {report_file}")
        
        # Exit with appropriate code
        if report["summary"]["setup_successful"]:
            sys.exit(0)
        else:
            sys.exit(1)
            
    except KeyboardInterrupt:
        print("\n\nâ¹ï¸  Setup interrupted")
        sys.exit(1)
    except Exception as e:
        print(f"\nâŒ Setup failed: {str(e)}")
        sys.exit(1)


if __name__ == "__main__":
    main()