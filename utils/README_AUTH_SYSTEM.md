# Comprehensive UUID Authorization System

This document describes the comprehensive error handling and logging system for UUID-based authorization in the Velro backend.

## Overview

The UUID Authorization System provides production-ready error handling, logging, circuit breakers, and monitoring for authorization failures. It addresses the common "HTTP 403 Access denied to this generation" errors with comprehensive debugging capabilities while maintaining security and performance.

## Architecture

### Core Components

1. **Exception Hierarchy** (`exceptions.py`)
   - Comprehensive authorization exception types
   - User-friendly error messages with technical details
   - Error categorization and severity levels

2. **Error Handler** (`auth_error_handler.py`)
   - Centralized error handling with recovery patterns
   - Security violation detection
   - Automatic retry mechanisms

3. **Logging System** (`auth_logger.py`)
   - Structured logging with security audit trails
   - Performance monitoring
   - Compliance logging for security audits

4. **Circuit Breaker** (`circuit_breaker.py`)
   - Fault tolerance for external dependencies
   - Graceful degradation patterns
   - Automatic recovery detection

5. **Integration System** (`auth_system.py`)
   - Unified API for all authorization operations
   - System health monitoring
   - Comprehensive metrics collection

## Quick Start

### Basic Integration

```python
from utils.auth_system import authorize_generation_access, handle_auth_error

@app.get("/api/v1/generations/{generation_id}")
async def get_generation(
    generation_id: str,
    request: Request,
    current_user: UserResponse = Depends(get_current_user)
):
    try:\n        # Authorize access with comprehensive error handling\n        auth_result = await authorize_generation_access(\n            user_id=str(current_user.id),\n            generation_id=generation_id,\n            action="read",\n            request=request\n        )\n        \n        # Proceed with business logic\n        return {"generation_id": generation_id, "auth": auth_result}\n        \n    except GenerationAccessDeniedError as e:\n        # Automatically handled with user-friendly messages\n        return await handle_auth_error(e, str(current_user.id), generation_id, "generation", request)\n```\n\n### Advanced Integration with Dependencies\n\n```python\nfrom utils.auth_integration_example import require_generation_access\n\n@app.get("/api/v1/generations/{generation_id}/secure")\nasync def get_generation_secure(\n    generation_id: str,\n    auth_result = Depends(require_generation_access(generation_id))\n):\n    # Authorization is automatically checked by dependency\n    return {"authorized": True, "auth_info": auth_result}\n```\n\n## Error Types and Handling\n\n### Authorization Exceptions\n\n#### GenerationAccessDeniedError\nSpecific error for generation access denial (HTTP 403).\n\n```python\nraise GenerationAccessDeniedError(\n    generation_id="uuid-here",\n    user_id="user-uuid",\n    owner_id="owner-uuid"\n)\n```\n\n**User Message**: \"Access denied. You don't have permission to access this generation.\"\n\n**Technical Details**: Includes generation ID, user ID, owner ID, and context.\n\n#### ProjectAccessDeniedError\nSpecific error for project access denial.\n\n```python\nraise ProjectAccessDeniedError(\n    project_id="project-uuid",\n    user_id="user-uuid"\n)\n```\n\n#### UUIDAuthorizationError\nGeneral UUID-based authorization error with detailed context.\n\n```python\nraise UUIDAuthorizationError(\n    message="Custom error message",\n    uuid_value="resource-uuid",\n    uuid_type="generation",\n    ownership_check_failed=True\n)\n```\n\n### Error Recovery Patterns\n\n1. **Automatic Retry** - For transient failures\n2. **Graceful Degradation** - When services are unavailable\n3. **Circuit Breaker** - For external dependencies\n4. **Fallback Strategies** - Conservative security defaults\n\n## Logging and Monitoring\n\n### Security Audit Logging\n\nAll authorization events are logged with structured data:\n\n```json\n{\n  "event_type": "access_denied",\n  "user_id": "hashed-user-id",\n  "resource_id": "hashed-resource-id",\n  "resource_type": "generation",\n  "denial_reason": "ownership_check_failed",\n  "timestamp": "2024-01-15T10:30:00Z",\n  "correlation_id": "req-uuid-123",\n  "client_ip": "hashed-ip",\n  "user_agent": "sanitized-ua",\n  "security_violation": false\n}\n```\n\n### Performance Monitoring\n\n```python\n# Automatic performance logging\nmetrics = AuthLogMetrics(\n    processing_time_ms=250.5,\n    database_queries=2,\n    cache_hits=1,\n    cache_misses=0\n)\n```\n\n### Security Event Detection\n\n- Repeated failed attempts\n- Suspicious UUID patterns\n- IP-based attack detection\n- Token manipulation attempts\n\n## Circuit Breaker Configuration\n\n### Database Operations\n\n```python\ndb_config = CircuitBreakerConfig(\n    failure_threshold=5,      # Open after 5 failures\n    recovery_timeout=60,      # Test recovery after 60s\n    success_threshold=3,      # Close after 3 successes\n    timeout=10.0,            # 10s operation timeout\n    fallback_function=safe_fallback  # Conservative fallback\n)\n```\n\n### Token Validation\n\n```python\ntoken_config = CircuitBreakerConfig(\n    failure_threshold=3,      # More sensitive\n    recovery_timeout=30,      # Faster recovery\n    timeout=5.0,             # Short timeout\n    fallback_function=deny_access  # Security-first fallback\n)\n```\n\n## System Health Monitoring\n\n### Health Check Endpoint\n\n```python\n@app.get("/api/v1/system/auth/health")\nasync def auth_health():\n    return await get_auth_system_health()\n```\n\n**Response**:\n```json\n{\n  "healthy": true,\n  "maintenance_mode": false,\n  "system_metrics": {\n    "total_requests": 1250,\n    "successful_requests": 1180,\n    "failed_requests": 70,\n    "error_rate": 5.6,\n    "average_response_time": 125.5\n  },\n  "circuit_breakers": {\n    "database": {"state": "closed", "failure_rate": 0.02},\n    "token_validation": {"state": "closed", "failure_rate": 0.01}\n  }\n}\n```\n\n## Configuration\n\n### Production Configuration\n\n```python\nproduction_config = AuthSystemConfig(\n    enable_circuit_breakers=True,\n    enable_detailed_logging=True,\n    enable_security_monitoring=True,\n    database_timeout=5.0,\n    max_failed_attempts_per_minute=20,\n    slow_operation_threshold_ms=500.0,\n    cache_ttl_seconds=600\n)\n```\n\n### Development Configuration\n\n```python\ndevelopment_config = AuthSystemConfig(\n    enable_circuit_breakers=False,  # Easier debugging\n    enable_detailed_logging=True,\n    enable_security_monitoring=False,\n    database_timeout=30.0,\n    max_failed_attempts_per_minute=100,\n    slow_operation_threshold_ms=2000.0\n)\n```\n\n## Common Use Cases\n\n### 1. Generation Access Control\n\n```python\n# Check if user owns generation\nresult = await authorize_generation_access(\n    user_id="user-uuid",\n    generation_id="gen-uuid", \n    action="read"\n)\n```\n\n### 2. Project Team Access\n\n```python\n# Check project membership\nresult = await authorize_project_access(\n    user_id="user-uuid",\n    project_id="project-uuid",\n    action="write"\n)\n```\n\n### 3. Token Validation\n\n```python\n# Comprehensive token validation\nresult = await validate_auth_token(\n    token="jwt-token-here",\n    token_type="access"\n)\n```\n\n### 4. Error Handling\n\n```python\ntry:\n    await authorize_generation_access(...)\nexcept GenerationAccessDeniedError as e:\n    # User-friendly error with technical details\n    return await handle_auth_error(e, ...)\nexcept CircuitBreakerError:\n    # Service unavailable - graceful degradation\n    return service_unavailable_response()\n```\n\n## Security Features\n\n### 1. Information Disclosure Prevention\n\n- Sanitized error messages in production\n- Hashed sensitive data in logs\n- Progressive disclosure for developers\n\n### 2. Attack Detection\n\n```python\n# Automatic detection of:\n- UUID enumeration attempts\n- Repeated access failures\n- Suspicious IP patterns\n- Token manipulation\n```\n\n### 3. Rate Limiting Integration\n\n```python\n# Automatic rate limiting for:\n- Failed login attempts\n- Authorization failures\n- Suspicious patterns\n```\n\n### 4. Compliance Logging\n\n- GDPR-compliant data handling\n- Audit trail generation\n- Security event correlation\n- Incident response support\n\n## Performance Optimization\n\n### 1. Caching Strategy\n\n```python\n# Multi-level caching:\n- L1: In-memory (60s TTL)\n- L2: Redis (5min TTL) \n- L3: Database fallback\n```\n\n### 2. Circuit Breaker Benefits\n\n- Prevents cascade failures\n- Reduces response latency\n- Automatic recovery detection\n- Graceful degradation\n\n### 3. Async Processing\n\n```python\n# Non-blocking operations:\n- Parallel authorization checks\n- Async logging\n- Background metrics collection\n```\n\n## Troubleshooting\n\n### Common Issues\n\n#### 1. "Access denied to this generation"\n\n**Cause**: User doesn't own the generation\n\n**Debug Steps**:\n1. Check correlation ID in logs\n2. Verify user ID and generation ID\n3. Check ownership in database\n4. Review authorization logs\n\n**Log Entry**:\n```json\n{\n  "event_type": "access_denied",\n  "correlation_id": "req-123",\n  "denial_reason": "ownership_check_failed",\n  "generation_id": "gen-456",\n  "user_id": "user-789"\n}\n```\n\n#### 2. Circuit Breaker Open\n\n**Cause**: Too many failures in database/auth service\n\n**Resolution**:\n1. Check service health\n2. Review circuit breaker metrics\n3. Wait for automatic recovery\n4. Manual reset if needed\n\n```python\n# Manual reset\nawait auth_system.reset_system_state()\n```\n\n#### 3. Slow Authorization\n\n**Cause**: Database performance issues\n\n**Debug**:\n1. Check processing time metrics\n2. Review slow query logs\n3. Analyze cache hit rates\n4. Check circuit breaker stats\n\n### Debug Commands\n\n```python\n# Get system health\nhealth = await get_auth_system_health()\n\n# Get detailed metrics\nmetrics = await get_auth_system_metrics()\n\n# Reset circuit breakers\nawait auth_system.reset_system_state()\n\n# Enable debug logging\nlogging.getLogger('velro.auth').setLevel(logging.DEBUG)\n```\n\n## Integration with Monitoring Systems\n\n### Sentry Integration\n\n```python\nimport sentry_sdk\n\n# Automatic error reporting\nsentry_sdk.capture_exception(auth_error)\n```\n\n### Metrics Export\n\n```python\n# Prometheus metrics\nauth_requests_total.inc()\nauth_errors_total.labels(error_type='access_denied').inc()\nauth_duration.observe(processing_time)\n```\n\n### Alerting Rules\n\n```yaml\n# Example alerting rules\n- alert: HighAuthErrorRate\n  expr: auth_error_rate > 10%\n  for: 5m\n  \n- alert: CircuitBreakerOpen\n  expr: circuit_breaker_state == 1\n  for: 1m\n```\n\n## Best Practices\n\n### 1. Error Handling\n\n✅ **DO**:\n- Always use the centralized error handler\n- Provide correlation IDs for debugging\n- Log security events appropriately\n- Use user-friendly error messages\n\n❌ **DON'T**:\n- Expose internal error details to users\n- Skip authorization checks\n- Log sensitive information\n- Ignore circuit breaker states\n\n### 2. Performance\n\n✅ **DO**:\n- Use circuit breakers for external dependencies\n- Implement proper caching strategies\n- Monitor performance metrics\n- Set appropriate timeouts\n\n❌ **DON'T**:\n- Make synchronous database calls\n- Skip performance monitoring\n- Use overly aggressive timeouts\n- Ignore slow operation alerts\n\n### 3. Security\n\n✅ **DO**:\n- Validate all UUIDs\n- Use conservative fallback strategies\n- Monitor for suspicious patterns\n- Implement proper audit logging\n\n❌ **DON'T**:\n- Allow enumeration attacks\n- Expose user ownership information\n- Skip security event logging\n- Use predictable error messages\n\n## API Reference\n\n### Main Functions\n\n```python\n# Authorization\nasync def authorize_generation_access(user_id, generation_id, action, request)\nasync def authorize_project_access(user_id, project_id, action, request)\n\n# Token validation\nasync def validate_auth_token(token, token_type, request)\n\n# Error handling\nasync def handle_auth_error(error, user_id, resource_id, resource_type, request)\n\n# System management\nasync def get_auth_system_health()\nasync def get_auth_system_metrics()\n```\n\n### Exception Classes\n\n```python\nclass GenerationAccessDeniedError(UUIDAuthorizationError)\nclass ProjectAccessDeniedError(UUIDAuthorizationError) \nclass TeamAccessDeniedError(UUIDAuthorizationError)\nclass TokenValidationError(AuthenticationError)\nclass CircuitBreakerError(Exception)\n```\n\n### Configuration Classes\n\n```python\nclass AuthSystemConfig\nclass CircuitBreakerConfig\nclass AuthLogContext\nclass AuthLogMetrics\n```\n\n## Migration Guide\n\n### From Basic Auth to Comprehensive System\n\n1. **Replace direct database checks**:\n   ```python\n   # Old\n   if generation.user_id != current_user.id:\n       raise HTTPException(403, "Access denied")\n   \n   # New\n   await authorize_generation_access(\n       str(current_user.id), generation_id, "read", request\n   )\n   ```\n\n2. **Update error handling**:\n   ```python\n   # Old\n   except Exception as e:\n       return {"error": str(e)}\n   \n   # New\n   except GenerationAccessDeniedError as e:\n       return await handle_auth_error(e, user_id, resource_id, resource_type, request)\n   ```\n\n3. **Add system monitoring**:\n   ```python\n   # Add health check endpoint\n   @app.get("/health/auth")\n   async def auth_health():\n       return await get_auth_system_health()\n   ```\n\nThis comprehensive system provides production-ready authorization with proper error handling, logging, monitoring, and security features while maintaining performance and user experience.