"""
Practical Integration Example: Updating Generations Router
Shows how to integrate the comprehensive auth system into existing routers.
"""
import logging
from typing import Optional, List
from fastapi import APIRouter, Depends, HTTPException, Query, Request, status
from fastapi.responses import JSONResponse

from middleware.auth import get_current_user
from models.user import UserResponse
from models.generation import GenerationResponse, GenerationListResponse

# Import the new auth system
from utils.auth_system import (
    authorize_generation_access, handle_auth_error, 
    auth_system, AuthSystemConfig
)
from utils.exceptions import GenerationAccessDeniedError, UUIDAuthorizationError
from utils.auth_logger import log_generation_access_attempt, AuthLogMetrics
from utils.circuit_breaker import CircuitBreakerError

logger = logging.getLogger(__name__)

# Updated generations router with comprehensive auth
enhanced_generations_router = APIRouter(tags=["generations"], prefix="/api/v1/generations")


@enhanced_generations_router.get("/{generation_id}", response_model=GenerationResponse)
async def get_generation_enhanced(
    generation_id: str,
    request: Request,
    current_user: UserResponse = Depends(get_current_user)
):
    """
    Get a specific generation with comprehensive authorization and error handling.
    
    This replaces the basic ownership check with the full auth system:
    - UUID validation
    - Ownership verification with database circuit breaker
    - Comprehensive error handling and logging
    - Security monitoring
    - Performance tracking
    """
    correlation_id = getattr(request.state, 'request_id', 'unknown')
    
    logger.info(
        f"üîç [GENERATION-API] Get generation request: {generation_id}",
        extra={
            'user_id': str(current_user.id),
            'generation_id': generation_id,
            'correlation_id': correlation_id
        }
    )
    
    try:\n        # Use comprehensive authorization system\n        auth_result = await authorize_generation_access(\n            user_id=str(current_user.id),\n            generation_id=generation_id,\n            action="read",\n            request=request\n        )\n        \n        # Log successful authorization\n        logger.info(\n            f"‚úÖ [GENERATION-API] Generation access authorized",\n            extra={\n                'user_id': str(current_user.id),\n                'generation_id': generation_id,\n                'processing_time_ms': auth_result.get('processing_time_ms'),\n                'correlation_id': correlation_id\n            }\n        )\n        \n        # Proceed with generation retrieval (your existing business logic)\n        try:\n            # Import generation service\n            from services.generation_service import generation_service\n            \n            # Get the generation data\n            generation = await generation_service.get_generation(\n                generation_id, \n                str(current_user.id)\n            )\n            \n            if not generation:\n                # This shouldn't happen after auth check, but safety first\n                raise GenerationAccessDeniedError(\n                    generation_id=generation_id,\n                    user_id=str(current_user.id),\n                    details={'reason': 'Generation not found after auth check'}\n                )\n            \n            return generation\n            \n        except Exception as service_error:\n            logger.error(\n                f"‚ùå [GENERATION-API] Service error after auth success: {service_error}",\n                extra={\n                    'user_id': str(current_user.id),\n                    'generation_id': generation_id,\n                    'correlation_id': correlation_id,\n                    'service_error': str(service_error)\n                }\n            )\n            \n            # Re-raise as HTTP exception for consistency\n            raise HTTPException(\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n                detail="Failed to retrieve generation data"\n            )\n    \n    except GenerationAccessDeniedError as auth_error:\n        # Comprehensive error handling with user-friendly messages\n        logger.warning(\n            f"üö´ [GENERATION-API] Generation access denied: {auth_error.message}",\n            extra={\n                'user_id': str(current_user.id),\n                'generation_id': generation_id,\n                'error_code': auth_error.error_code,\n                'correlation_id': correlation_id\n            }\n        )\n        \n        # Use centralized error handler\n        return await handle_auth_error(\n            auth_error,\n            user_id=str(current_user.id),\n            resource_id=generation_id,\n            resource_type="generation",\n            request=request\n        )\n    \n    except CircuitBreakerError as cb_error:\n        # Handle circuit breaker errors gracefully\n        logger.error(\n            f"üî• [GENERATION-API] Circuit breaker error: {cb_error}",\n            extra={\n                'user_id': str(current_user.id),\n                'generation_id': generation_id,\n                'circuit_name': cb_error.circuit_name,\n                'circuit_state': cb_error.state.value,\n                'correlation_id': correlation_id\n            }\n        )\n        \n        return JSONResponse(\n            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,\n            content={\n                'error': True,\n                'message': 'Authorization service temporarily unavailable. Please try again in a moment.',\n                'error_type': 'service_unavailable',\n                'correlation_id': correlation_id,\n                'retry_after': 60\n            }\n        )\n    \n    except Exception as unexpected_error:\n        # Handle any unexpected errors\n        logger.error(\n            f"‚ùå [GENERATION-API] Unexpected error: {unexpected_error}",\n            extra={\n                'user_id': str(current_user.id),\n                'generation_id': generation_id,\n                'error_type': type(unexpected_error).__name__,\n                'correlation_id': correlation_id\n            }\n        )\n        \n        # Use centralized error handler for consistency\n        return await handle_auth_error(\n            unexpected_error,\n            user_id=str(current_user.id),\n            resource_id=generation_id,\n            resource_type="generation", \n            request=request\n        )\n\n\n@enhanced_generations_router.get("", response_model=GenerationListResponse)\nasync def list_generations_enhanced(\n    request: Request,\n    project_id: Optional[str] = Query(None, description="Filter by project ID"),\n    page: int = Query(1, ge=1, description="Page number"),\n    limit: int = Query(20, ge=1, le=100, description="Items per page"),\n    current_user: UserResponse = Depends(get_current_user)\n):\n    """\n    List user's generations with optional project filtering.\n    Includes comprehensive authorization for project-filtered requests.\n    """\n    correlation_id = getattr(request.state, 'request_id', 'unknown')\n    \n    try:\n        # If project_id is specified, authorize project access first\n        if project_id:\n            logger.info(\n                f"üîç [GENERATION-API] Authorizing project access for generation list",\n                extra={\n                    'user_id': str(current_user.id),\n                    'project_id': project_id,\n                    'correlation_id': correlation_id\n                }\n            )\n            \n            # Use project authorization\n            from utils.auth_system import authorize_project_access\n            \n            project_auth = await authorize_project_access(\n                user_id=str(current_user.id),\n                project_id=project_id,\n                action="read",\n                request=request\n            )\n            \n            logger.info(\n                f"‚úÖ [GENERATION-API] Project access authorized for generation list",\n                extra={\n                    'user_id': str(current_user.id),\n                    'project_id': project_id,\n                    'processing_time_ms': project_auth.get('processing_time_ms'),\n                    'correlation_id': correlation_id\n                }\n            )\n        \n        # Proceed with generation listing\n        from services.generation_service import generation_service\n        \n        generations = await generation_service.list_user_generations(\n            user_id=str(current_user.id),\n            project_id=project_id,\n            page=page,\n            limit=limit\n        )\n        \n        return generations\n        \n    except Exception as e:\n        # Handle errors with comprehensive system\n        return await handle_auth_error(\n            e,\n            user_id=str(current_user.id),\n            resource_id=project_id,\n            resource_type="project" if project_id else "generation_list",\n            request=request\n        )\n\n\n@enhanced_generations_router.delete("/{generation_id}")\nasync def delete_generation_enhanced(\n    generation_id: str,\n    request: Request,\n    current_user: UserResponse = Depends(get_current_user)\n):\n    """\n    Delete a generation with comprehensive authorization.\n    Requires 'delete' action permission (higher than 'read').\n    """\n    correlation_id = getattr(request.state, 'request_id', 'unknown')\n    \n    try:\n        # Authorize delete action (stricter than read)\n        auth_result = await authorize_generation_access(\n            user_id=str(current_user.id),\n            generation_id=generation_id,\n            action="delete",\n            request=request\n        )\n        \n        logger.info(\n            f"üóëÔ∏è [GENERATION-API] Generation delete authorized",\n            extra={\n                'user_id': str(current_user.id),\n                'generation_id': generation_id,\n                'correlation_id': correlation_id\n            }\n        )\n        \n        # Proceed with deletion\n        from services.generation_service import generation_service\n        \n        success = await generation_service.delete_generation(\n            generation_id,\n            str(current_user.id)\n        )\n        \n        if success:\n            return JSONResponse(\n                status_code=status.HTTP_200_OK,\n                content={\n                    'success': True,\n                    'message': 'Generation deleted successfully',\n                    'generation_id': generation_id,\n                    'correlation_id': correlation_id\n                }\n            )\n        else:\n            raise HTTPException(\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n                detail="Failed to delete generation"\n            )\n            \n    except Exception as e:\n        return await handle_auth_error(\n            e,\n            user_id=str(current_user.id),\n            resource_id=generation_id,\n            resource_type="generation",\n            request=request\n        )\n\n\n@enhanced_generations_router.get("/system/health")\nasync def generation_auth_health():\n    """\n    Health check endpoint specifically for generation authorization.\n    Shows the health of auth components used by generation endpoints.\n    """\n    try:\n        # Get comprehensive system health\n        health = await auth_system.check_system_health()\n        \n        # Focus on generation-relevant components\n        generation_health = {\n            'healthy': health['healthy'],\n            'timestamp': health['timestamp'],\n            'components': {\n                'database_circuit_breaker': health['circuit_breakers'].get('database', {}).get('state') == 'closed',\n                'token_validation': health['circuit_breakers'].get('token_validation', {}).get('state') == 'closed',\n                'error_handler': health['subsystem_health'].get('error_handler', False),\n                'logger': health['subsystem_health'].get('logger', False)\n            },\n            'metrics': {\n                'total_requests': health['system_metrics']['total_requests'],\n                'error_rate': health['system_metrics']['error_rate'],\n                'average_response_time': health['system_metrics']['average_response_time']\n            }\n        }\n        \n        status_code = status.HTTP_200_OK if generation_health['healthy'] else status.HTTP_503_SERVICE_UNAVAILABLE\n        \n        return JSONResponse(\n            status_code=status_code,\n            content=generation_health\n        )\n        \n    except Exception as e:\n        logger.error(f"‚ùå [GENERATION-API] Health check failed: {e}")\n        return JSONResponse(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            content={\n                'healthy': False,\n                'error': 'Health check failed',\n                'message': str(e)\n            }\n        )\n\n\n# Migration helper functions\n\ndef migrate_existing_generation_routes():\n    """\n    Helper function showing how to migrate existing routes.\n    \n    BEFORE (existing route):\n    ```python\n    @router.get("/{generation_id}")\n    async def get_generation(generation_id: str, current_user = Depends(get_current_user)):\n        # Direct database check\n        generation = await db.get_generation(generation_id)\n        if generation.user_id != current_user.id:\n            raise HTTPException(403, "Access denied")\n        return generation\n    ```\n    \n    AFTER (enhanced route):\n    ```python\n    @router.get("/{generation_id}")\n    async def get_generation(generation_id: str, request: Request, current_user = Depends(get_current_user)):\n        try:\n            # Comprehensive authorization\n            await authorize_generation_access(str(current_user.id), generation_id, "read", request)\n            generation = await db.get_generation(generation_id)\n            return generation\n        except GenerationAccessDeniedError as e:\n            return await handle_auth_error(e, str(current_user.id), generation_id, "generation", request)\n    ```\n    """\n    pass\n\n\ndef setup_generation_router_middleware():\n    """\n    Example of setting up middleware specifically for generation routes.\n    """\n    \n    # Custom middleware for generation-specific logging\n    class GenerationAuthMiddleware:\n        def __init__(self, app):\n            self.app = app\n        \n        async def __call__(self, scope, receive, send):\n            if scope["type"] == "http" and scope["path"].startswith("/api/v1/generations/"):\n                # Add generation-specific tracking\n                scope["state"] = scope.get("state", {})\n                scope["state"]["auth_context"] = "generations"\n                \n                # Log generation endpoint access\n                logger.info(f"üé® [GENERATION-ACCESS] {scope['method']} {scope['path']}")\n            \n            await self.app(scope, receive, send)\n    \n    return GenerationAuthMiddleware\n\n\n# Error handler specifically for generation routes\nasync def generation_error_handler(request: Request, exc: Exception) -> JSONResponse:\n    """\n    Specialized error handler for generation-related errors.\n    Provides context-specific error messages and recovery suggestions.\n    """\n    \n    # Extract generation ID from path if available\n    generation_id = None\n    path_parts = request.url.path.split('/')\n    if 'generations' in path_parts:\n        try:\n            gen_index = path_parts.index('generations')\n            if len(path_parts) > gen_index + 1:\n                potential_id = path_parts[gen_index + 1]\n                # Basic UUID validation\n                if len(potential_id) == 36 and potential_id.count('-') == 4:\n                    generation_id = potential_id\n        except (ValueError, IndexError):\n            pass\n    \n    # Get user from request state if available\n    user_id = getattr(request.state, 'user_id', None)\n    \n    # Use comprehensive error handler\n    return await handle_auth_error(\n        exc,\n        user_id=user_id,\n        resource_id=generation_id,\n        resource_type="generation",\n        request=request\n    )\n\n\n# Configuration for generation-specific auth settings\ngeneration_auth_config = AuthSystemConfig(\n    enable_circuit_breakers=True,\n    enable_detailed_logging=True,\n    enable_security_monitoring=True,\n    enable_performance_monitoring=True,\n    \n    # Generation-specific timeouts (faster for better UX)\n    database_timeout=5.0,\n    token_validation_timeout=3.0,\n    \n    # Generation-specific security settings\n    max_failed_attempts_per_minute=15,  # Slightly more lenient for creative workflows\n    max_failed_attempts_per_hour=150,\n    \n    # Performance settings optimized for generation workloads\n    slow_operation_threshold_ms=800.0,  # Generations can be slower\n    cache_ttl_seconds=300,  # 5 minute cache for generation metadata\n    metrics_retention_hours=72  # Longer retention for analytics\n)\n\n\n# Example of how to integrate with FastAPI app\ndef setup_enhanced_generation_router(app):\n    """\n    Setup the enhanced generation router with comprehensive auth.\n    """\n    \n    # Add the enhanced router\n    app.include_router(enhanced_generations_router)\n    \n    # Add generation-specific exception handlers\n    @app.exception_handler(GenerationAccessDeniedError)\n    async def generation_access_handler(request: Request, exc: GenerationAccessDeniedError):\n        return await generation_error_handler(request, exc)\n    \n    # Add middleware for generation context\n    middleware_class = setup_generation_router_middleware()\n    app.add_middleware(middleware_class)\n    \n    logger.info("‚úÖ [SETUP] Enhanced generation router configured with comprehensive auth")\n\n\n# Performance optimization for generation authorization\nclass GenerationAuthOptimizer:\n    """\n    Optimizations specific to generation authorization patterns.\n    """\n    \n    @staticmethod\n    async def batch_authorize_generations(\n        user_id: str,\n        generation_ids: List[str],\n        action: str = "read"\n    ) -> Dict[str, bool]:\n        """\n        Batch authorization check for multiple generations.\n        More efficient than individual checks for list operations.\n        """\n        results = {}\n        \n        # Group by likely ownership patterns to optimize database queries\n        # This would integrate with the actual generation service\n        for gen_id in generation_ids:\n            try:\n                await authorize_generation_access(user_id, gen_id, action)\n                results[gen_id] = True\n            except GenerationAccessDeniedError:\n                results[gen_id] = False\n            except Exception:\n                results[gen_id] = False  # Conservative fallback\n        \n        return results\n    \n    @staticmethod\n    async def preauthorize_project_generations(\n        user_id: str,\n        project_id: str\n    ) -> bool:\n        """\n        Pre-authorize access to a project for bulk generation operations.\n        Returns True if user has project access, enabling optimized generation checks.\n        """\n        try:\n            from utils.auth_system import authorize_project_access\n            await authorize_project_access(user_id, project_id, "read")\n            return True\n        except Exception:\n            return False